# PRELIMINARIES
- [x] implement COO multiplication with vector
- [x] implement CSR multiplication with vector

# DELIVERABLE
- [x] implement conversion COO to CSR
- [x] verify quickly how the cluster running works (like, which commands are needed)
- [x] once done that, try to run the first draft of the script and get results on the cluster
- [x] these are dummy results, as we have not dealt in depth with the parallelization part
- [x] once done that, study deeply what to do to parallelize the code 
- [ ] AND optimize the cache, you have various options, make sure to consider them all -> 
        identify which are the thread shared variables, if there are any at all 
- [ ] plot the resulting data into a matlab scipt to plot the results
- [ ] check literature for conclusion
- [ ] write it all
- [ ] examine the cache performance of sequential code under 5 different type of sparse matrices (this allows you to verify the code is working and general purpose as well) 



# TO DO TODAY
- [ ] plot spmv_static, spvm_dynamic, spvm_guided, spvm_manual information(s) FIRST (with all different 
        matrices AND different architectures) -> TOMORROW ASK TUTOR IF THIS MODE OF PROCEEDING IS FINE
- [ ] write paper information regarding this part FIRST
- [ ] then, you may implement other pragma omp options:  
        - [ ] CHUNK SIZE, 
        - [ ] AUTO, 
        - [ ] pragma barriers, 
        - [ ] REDUCTION and so on

-------------------------------
DELIVERABLE1 INSTRUCTION
-------------------------------

1) Read Matrix in Matrix Format and convert to CSR
2) Multiply the Matrix with a randomly generated array
3) Design a parallel code on a shared-memory system (using ....)



1) write python script that generates a random sparse matrix into a .mtx file
2) convert the COO format from .mtx file into a CSR format matrix
3) figure out how to do MV product
4) experiment with different parallelization techniques, making sure it works corrctly

COO MATRIX:
you're given a matrix in COO format (with the 3 arrays);
you have:
# rows
# columns
# nz elements
you want:

row_indixes[i] , col_indexes[j], values[k] -> Matrix format
since C stores elements in a row major fashion:

row_index[i]*leading_dimension + col_index[j] = val[i][j] 

*/




/* 
*   Matrix Market I/O example program
*
*   Read a real (non-complex) sparse matrix from a Matrix Market (v. 2.0) file.
*   and copies it to stdout.  This porgram does nothing useful, but
*   illustrates common usage of the Matrix Matrix I/O routines.
*   (See http://math.nist.gov/MatrixMarket for details.)
*
*   Usage:  a.out [filename] > output
*
*       
*   NOTES:
*
*   1) Matrix Market files are always 1-based, i.e. the index of the first
*      element of a matrix is (1,1), not (0,0) as in C.  ADJUST THESE
*      OFFSETS ACCORDINGLY offsets accordingly when reading and writing 
*      to files.
*
*   2) ANSI C requires one to use the "l" format modifier when reading
*      double precision floating point numbers in scanf() and
*      its variants.  For example, use "%lf", "%lg", or "%le"
*      when reading doubles, otherwise errors will occur.
*/


